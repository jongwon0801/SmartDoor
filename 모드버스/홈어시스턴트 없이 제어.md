#### 라즈베리파이에서 해당 시리얼 포트를 확인
```less
ls -la /dev/serial/by-id/

lrwxrwxrwx 1 root root 13  9월 12 10:20 usb-FTDI_FT232R_USB_UART_AK3XEFC4-if00-port0 -> ../../ttyUSB0
```

#### 패키지 설치
```less
pip install pymodbus==2.5.3

pip show pymodbus
```

```less
import logging
import time
import threading
from pymodbus.client.sync import ModbusSerialClient

# -------------------
# 로깅 설정
# -------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("modbus_control.log"),
    ],
)
_log = logging.getLogger("ModbusControl")

# -------------------
# Modbus 시리얼 설정 (RS-485)
# -------------------
MODBUS_CONFIG = {
    "method": "rtu",
    "port": "/dev/serial/by-id/usb-FTDI_FT232R_USB_UART_AK3XEFC4-if00-port0",
    "baudrate": 9600,
    "bytesize": 8,
    "parity": "N",
    "stopbits": 1,
    "timeout": 1,
}

# -------------------
# 스위치 정의
# -------------------
MODBUS_SWITCHES = {
    "OUT 1": {"slave": 1, "address": 0, "command_on": 0x0100, "command_off": 0x0200},
    "OUT 2": {"slave": 1, "address": 1, "command_on": 0x0100, "command_off": 0x0200},
    "OUT 8": {"slave": 1, "address": 7, "command_on": 0x0100, "command_off": 0x0200},
}

# -------------------
# 센서 정의
# -------------------
MODBUS_SENSORS = {
    "IN 1": {"slave": 1, "address": 192, "scan_interval": 1},
}

# -------------------
# 상태 저장
# -------------------
switch_states = {sw: False for sw in MODBUS_SWITCHES}
sensor_states = {sn: None for sn in MODBUS_SENSORS}

# -------------------
# 수동 조작 플래그
# -------------------
manual_override = {sw: False for sw in MODBUS_SWITCHES}

# -------------------
# Modbus 클라이언트 생성
# -------------------
client = ModbusSerialClient(**MODBUS_CONFIG)
if not client.connect():
    print("Modbus 시리얼 연결 실패")
    exit(1)

# -------------------
# 센서 읽기
# -------------------
def read_sensors():
    for name, cfg in MODBUS_SENSORS.items():
        try:
            response = client.read_holding_registers(cfg["address"], 1, unit=cfg["slave"])
            if not response.isError():
                value = response.registers[0]
                if value != sensor_states[name]:
                    _log.info(f"센서 {name} 값: {value}")
                sensor_states[name] = value
            else:
                _log.error(f"{name} 읽기 오류: {response}")
        except Exception as e:
            _log.error(f"{name} 읽기 예외: {e}")

# -------------------
# 스위치 쓰기
# -------------------
def write_switch(name, value):
    cfg = MODBUS_SWITCHES[name]
    try:
        response = client.write_register(cfg["address"], value, unit=cfg["slave"])
        if response.isError():
            _log.error(f"{name} 쓰기 오류: {response}")
            return False
        else:
            _log.info(f"{name} 설정 완료: {value}")
            return True
    except Exception as e:
        _log.error(f"{name} 쓰기 예외: {e}")
        return False

# -------------------
# 자동화 로직
# -------------------
def automation_logic():
    in1 = sensor_states.get("IN 1")
    if in1 is None:
        return

    # OUT 8 자동화
    if manual_override["OUT 8"]:
        # 수동 모드면 자동화 건드리지 않음
        return

    if in1 > 0:
        if not switch_states["OUT 8"]:
            _log.info("IN 1 > 0 감지, OUT 8 켜기 (자동)")
            if write_switch("OUT 8", MODBUS_SWITCHES["OUT 8"]["command_on"]):
                switch_states["OUT 8"] = True
                manual_override["OUT 8"] = False  # 자동으로 켰음을 표시
    else:
        if switch_states["OUT 8"]:
            _log.info("IN 1 < 1 감지, OUT 8 끄기 (자동)")
            if write_switch("OUT 8", MODBUS_SWITCHES["OUT 8"]["command_off"]):
                switch_states["OUT 8"] = False
                manual_override["OUT 8"] = False  # 자동으로 껐음을 표시

# -------------------
# 명령어 인터페이스
# -------------------
def command_interface():
    print("\n===== Modbus 제어 시스템 =====")
    print("명령어: status / on <번호> / off <번호> / auto <번호>\n")

    while True:
        cmd = input("> ").strip().lower()

        if cmd == "status":
            print("\n----- 상태 -----")
            for sw, st in switch_states.items():
                mode = "수동" if manual_override[sw] else "자동"
                print(f"{sw}: {'켜짐' if st else '꺼짐'} ({mode})")
            for sn, val in sensor_states.items():
                print(f"{sn}: {val}")
            print("----------------\n")

        elif cmd.startswith("on "):
            try:
                num = int(cmd.split()[1])
                sw = f"OUT {num}"
                if sw in MODBUS_SWITCHES:
                    if write_switch(sw, MODBUS_SWITCHES[sw]["command_on"]):
                        switch_states[sw] = True
                        manual_override[sw] = True  # 수동 모드 설정
                else:
                    print(f"{sw} 없음")
            except ValueError:
                print("사용법: on <번호>")

        elif cmd.startswith("off "):
            try:
                num = int(cmd.split()[1])
                sw = f"OUT {num}"
                if sw in MODBUS_SWITCHES:
                    if write_switch(sw, MODBUS_SWITCHES[sw]["command_off"]):
                        switch_states[sw] = False
                        manual_override[sw] = True  # 수동 모드 설정
                else:
                    print(f"{sw} 없음")
            except ValueError:
                print("사용법: off <번호>")

        elif cmd.startswith("auto "):
            try:
                num = int(cmd.split()[1])
                sw = f"OUT {num}"
                if sw in MODBUS_SWITCHES:
                    manual_override[sw] = False  # 자동화 모드로 전환
                    print(f"{sw} 자동 제어 모드로 전환")
                else:
                    print(f"{sw} 없음")
            except ValueError:
                print("사용법: auto <번호>")

        else:
            print("알 수 없는 명령")

# -------------------
# 메인 루프
# -------------------
if __name__ == "__main__":
    try:
        # 명령 인터페이스를 별도 스레드에서 실행
        cmd_thread = threading.Thread(target=command_interface, daemon=True)
        cmd_thread.start()

        while True:
            read_sensors()
            automation_logic()
            time.sleep(0.5)

    except KeyboardInterrupt:
        print("\n사용자 종료")
    finally:
        client.close()

```











